// Пример модификаторов, классов, пространств имён и комментариев.
0210010011
public class Namespace1.PublicClass
    // TODO Пример заметки на исправление.
	class Namespace3.PrivateClass1: Interface1, Namespace1.Interface2
	private class Namespace3.PrivateClass2
	private protected class Namespace4.Namespace5.PrivateProtectedClass
	protected class ProtectedClass : IExample1, IExample2
	protected internal class ProtectedInternalClass
		public void Method1(bool argument1, bool argument2)

/*
	Многострочный комментарий.
	CRUTCH Пример некачественного кода.
*/
internal class Namespace2.InternalClass

// Пример подключения пространства имён.
using Scope1.Scope2.Scope3 // Вариант namespace == scope? import?

// TODO Необходимо подумать о выделении памяти под локальные объекты и обращении к ним.
void Sort(256 array[4][10])
	// Тип данных является числом 256^(4*10) состояний.
	256[4] i, j, k // Ассоциативность допускает запись вида 256 i[4], j[4], k[4], где 256 - основание.
	// Состояния можно рассматривать как представление данных.
	// TODO Копировать ленту полностью или только указатели?
	2[8][4][10] same = array // Или 4294967296[10] same = array.
	// Чтобы не делать явное преобразование, можно опускать часть измерений кроме N-последних например.
	// Тип элемента при этом будет вычислен как M-N, где M - все измерения с основанием.
	for (i = 0; i < 10; i++)
		for (j = 0; j < 10; j++)
			if (same[i] > same[j])
				k = same[j]
				same[j] = same[i]
				same[i] = k

	// Вывод на экран.
	for (i = 0; i < 10; i++) { // TODO Необходимо продумать возможность использовать необязательных конструкций.
		Console.Write($"{same[i]} "); // TODO Типа скобок и точки с запятой.
	}
	Console.WriteLine()

// Глобальная область видимости необходима?
// Может заменить точку входа или дать возможность выполнять программы из консоли?
void MainTopScope() // Ключевое слово static необязательно.
	// TODO Сомнительное решение, но может функции и методы по умолчанию вызывать без скобок как в консоли?
	Sort({4, 8, 1, 0, 9, 2, 7, 3, 6, 5})
	Console.WriteLine("Global scope can provide recursive inclusion?")

class Program
	static 256[] text = "routine"
	static void Main()
		Console.WriteLine($"This is proc {text}.")

// Типы и системы счисления.
#define bit 2
#define byte bit[8]
byte test1 = 100
2[8] test2 = 100

// Расширенная (придумать название) запись числа может производиться в одной системе.
// Двоеточие - это фактически разделение разрядов для поддержки чисел высоких систем счисления > 36.
// Может использоваться для сериализации / десериализации данных и описания объектов.
// Такой описатель легко может быть приведён к другому основанию с тем же размером,
// что даёт возможность представлять данные по-другому, в других системах.
// А с учётом типизации, одномерные массивы можно преобразовать к N-мерным.
// Если указан префикс, то остальные компоненты записи могут использовать лидирующие ноли.
enum TimeType
	Am = 0
	Pm = 1

TimeType:12:60:60 time = 0f: TimeType.Am:03:10:20
0f 0:03:10:20
// Можно сделать 10-ую запись по умолчанию, если префикса нет, а компонентам записи
// сразу разрешить лидирующие ноли.

// Вариант рассмотрения описателей лент, как указателей с возможностью наследования.
2 binary = new 2[8] { 0, 1, 1, 1, 0, 0, 1, 1 }
2 binary = (2)10010010010
2 binary = 100 // dec
2 binary = (3)0122112 // Фактически указатель на объект основания 3. Он может быть любой длины,
// зависит от выделенной памяти. Типа как char*. Соответственно ленты любых оснований и
// и размеров можно представлять в любых вариациях.
t = ((2)001001)0ffff
TimeType:12:60:60 t = (:::16)TimeType.Am:03:(16)010:0f

3[1][5,8]

Parent = (Parent)(Base)Child;

0100000000 // Унарная система.
0210010011 // Двоичная система.

000542
0a000542

..
0a123 = 123 // Десятичная система счисления.
0gfffff // Шестнадцатиричная.
..
0#zzzzzz // TODO 36-ричная крайняя, символ надо выбрать.

01 = 1
0o = 24
0g = 16

0f[2] byte = 0fff //? f = 15
0g[2] byte = 0gff
0r[2] test = 0rpp

9[2] val = 0987 // 81 состояний. Ошибка, не хватает размера для записи 87.
10[2] val = 0a99 // 100 состояний от 0 до 99

// Вариант с равным префиксом.
0z = // (36-ричная система счисления).
0zz = 35
0z10 = 36

// Двоичная система.
01 =
010 = 0
011 = 1
0110 = 2
0111 = 3

private enum BinaryIpMask
	ClassA = 0100001000
	ClassB = 0100000100
	ClassC = 0100000010
	ClassD = 0100000001

0a20100
0x100101:0001001:1101001:101
0o:60:60
0z:60:60
0#:60:60 = 36:60:60
37:60:60

// 21h = 0f21
500:500 test =    059:001 // Ошибка 059 - лидирующий ноль, 5-ная система счисления недостаточна для основания 500.
// Можно кстати такую запись всегда трактовать как десятичная. Но это может также привести к путанице.
// Либо вариант - 0 включает режим разрядов для представления в любой системе счисления, тогда, чтобы записать
// число с большим основанием, но десятичными числами, еще и с лидирующими нулями, то нужно сделать явный каст:
500:500 test = (10:10)059:001
500:500 test = 59:1 = ( 59:  1) // Кстати надо теперь подумать, как каст отличить от выражения xD
// Как вариант между кастом и операндом нет оператора.

500:500 test = 0f 05a:0a1

// IPv6 example.
2001:0db8:0000:0000:0000:ff00:0042:8329 // В такой записи не учитывать 0?
2001:db8:0:0:0:ff00:42:8329
2001:db8::ff00:42:8329
0000:0000:0000:0000:0000:0000:0000:0001
::1

24:60:60 time = 0xc:30:0b01101
24:60:60 test = (16)11:1f:1a // Расширенная запись.
// Фактически разряды, записываемые в разных системах счисленя можно представить как обычные поля класса.
class Test
	2[8] byteVal
	3[6] trite
	60 minutes
// Эквивалентно
2[8]:3[6]:60 // типу. Эта форма скорее будет редкой. Фактически расширенная форма для представления данных в системах > Z.
// Она также может быть использована для сериализации/десериализации объектов.
(16)11:1f:1a // Как это трактовать?
// 24:60:60 - это не просто тип, а прям описание машины как у Тьюринга xD. Вообще это эквивалентно 24*60*60 состояний = сутки = 86400 секунд-состояний.
// любое число состояний можно привести к любому основанию (не всегда ровно, тем не менее).
// Тогда (16)24:60:60 ~ (16)86400 ~ 16[4] (ну с кастом надо конеш подумать, какая-то какаха пока что выходит).
// Нужно сохранить возможность использования {0, 1, 2, 3} множеств.

query[1] = (byte) (ID & 0xFF);
query[1] = (byte) (ID & (16)FF)

buffer[offset++] = (byte)((m_Source >> 24) | 0xFF);
buffer[offset++] = (byte)((m_Source >> 24) | (16)FF)

_mp3Writer.BaseStream.Write(new byte[] { value, 0, 0x07, 0x76 }, 0, 4);
_mp3Writer.BaseStream.Write((36)value: (16) 00 07 76, 0, 4)

byte[] notCsbkRelayRequest = { 0x09, 0x12, 0x22, 0x04, 0x00, 0x00, 0x00, 0x05, 0x26, 0x0C, 0x00, 0x00, 0x06, 0x51, 0x42, 0x0a, 0x62, 0x34, 0x31, 0x64 };
16[2][] notCsbkRelayRequest = { 009, 012, 004, 000, 000, 000, 005, 026, 00C, 000, 000, 006, 051, 042, 00a, 062, 034, 031, 064 }
16[2][] notCsbkRelayRequest = { 0 09 12 04 00 00 00 05 26 0C 00 00 06 51 42 0a 62 34 31 64 }
enum DmoHResults { DMO_E_INVALIDSTREAMINDEX = unchecked((int)0x80040201), }
Unit2Unit ? 0x3 : 0u

var t = (2) 00 11 01 00 10 // Указатель?
var time = (24:(16)3C:60)12:50:30
var ambig = (36)time // Ошибка, идентификатор или число?
print(t[3]) // 1

var t = 2x 00 11 01 00 10
var time = (24:16x3C:60)12:50:30
var ambig = 36xtime // нет ошибки

// Заметки.
git lg -10
git(lg(10))
git.lg(10)

// Вариант записи в разных системах счисления.
// 1. Число всегда начинается с цифры.
// 2. Если число содержит лидирующий ноль, то запись числа должна соответствовать основанию типа данных.
// 3. Каст может изменить основание записи числа, тем самым привести к записи в другой системе счисления.
2[8] val = 100
2[8] val = 011011011 // Двоичное число 9-ый разряд не учитывается.
2[8] val = (16)0ff // Шестнадцатиричная запись.
16 val = 0ff // Если основания совпадают.
2[8] val = (256)0ff // Ошибка. Разряд числа с основанием 256 нельзя записать одним символом, т.к. не хватит алфавита.

// Приведение типов для констант.
// Размер переменной может быть отличен от размерности константы.
// Как вариант приведение к меньшему основанию не должен обрезать число (наверное)
256[2] eightBytes = (16)0ffff // По идее не должно обрезаться (это неточно).
256[2] eightBytes = (16[])0ffff // Скорее это является полной записью. Но выглядит излишним.
