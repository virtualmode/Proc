// Представление чисел (невероятная идея 2.0).


// Все последовательности чисел и букв являются числами (для записи в любой системе счисления).
// Числа могут представляться с лидирующим нулем или без него.
001
12345ff
fdfafc
// Идентификаторы всегда начинаются с буквы или подчеркивания (хотя теперь это не обязательно).
_identifier
мой_идентификатор
// TODO Экспоненциальная запись пока что возможна только в десятичной форме и вещественные числа.
0.3218e+8
// Знак числа может быть добавлен как в контексте выражения, так и без.
+0
-0


// TODO Постфиксная запись типа числа пока не представляется возможной.
// TODO Число можно записывать через пробелы, табуляции, новые строки и другие невидимые разделители до операторов, разделителей или ключевых слов.


// Числа становятся зависимы от контекста использования. Что-то типа когда float делишь на int, второй представляется с плавающей точкой.
// Основные типы данных объявляются с основанием 10.
// Определение переменной всегда считается числом в десятичной системе счисления, если не выполнен каст.
// Контекст всегда соответствует левой части выражения, если не произведён каст.
2[8] byte = 10010010
2[8] byte = (10)255
(10)2[8] byte = 255
16[4]:16[4]:16[4]:16[4]:16[4]:16[4]:16[4]:16[4] ipv6 = 2001:0db8:0000:0000:0000:ff00:0042:8329
// Соответственно запись эквивалентна 16^4 + 16^4 + ... 8 раз. Можно сократить до 16[32]
16[32] ipv6 = 2001:db8:0:0:0:ff00:42:8329
(10)16[32] ipv6 = 8193:3512::65280:66:33577
16[32] ipv6 = (10)(8193:3512::65280:66:33577) // По поводу приоритета каста и скобок надо подумать.


// Запись чисел в других системах счисления.

ffff // Некоторое число с неизвестной системой счисления, определяемой контекстом или идентификатор.
0 xz zq ff // Предполагается возможность записи данных в виде лент.
// Из-за этой особенности система счисления может быть определена только в контексте использования.

// Каст не обрезает данные (как ссылочный тип?), не меняет данные и их тип, он указывает класс через который данные представляются в выражении.
(16)ffff // Шестнадцатиричное число.
((16)g)ffff // Тоже самое.


// Основные примеры использования.
#define int (10)2[8]
#define byte (10)2[8]
byte test = 255
2[8] test = 10010010
16[2] test = ff
16[2] test = (10)255
// Из-за такой особенности, если захотеть 3-х значное десятичное число представлять в шестнадцатиричном виде,
// то его определение будет выглядеть странно, тем не менее.
10[3] test = 100
10[3] test = (16)64
(16)a[3] test = 64 // Это запись должна редко использоваться и фактически нужна только для определения типа данных.
// Основные десятичные типы данных будут созданы сразу, остальной изврат уже на совести программистов.
for (int i = 0; i < 10; i++)
	write("iteration")
