/* Parsing expression grammar (PEG) of Proc
Wirth Extended Backus-Naur Form of Proc
http://www.cs.man.ac.uk/~pjj/bnf/ebnf.html
https://certitude.consulting/blog/en/invisible-backdoor/ */

{
    parserClass="proc.ProcParser"
    parserUtilClass="proc.ProcParserUtil"

    extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

    psiClassPrefix="Proc"
    psiImplClassSuffix="Impl"
    psiPackage="proc.psi"
    psiImplPackage="proc.psi.impl"

    elementTypeHolderClass="proc.psi.ProcSymbolType"
    elementTypeClass="proc.psi.ProcElementType"
    elementTypeFactory("nativeDataDecl|dataDecl|newtypeDecl|typeDecl|construct|program|binding|nativeFunction|classDecl|instanceDecl|annotationItem|label|accessModifier")
        ="proc.psi.ProcElementTypeFactory.factory"
    tokenTypeClass="proc.psi.ProcTokenType"
}

procFile ::= !<<eof>> program


/* Util Meta Rules */
private meta commaSequence ::= <<rule>> (COMMA <<rule>>)*
private meta semicolonSequence ::= <<rule>> (SEMICOLON <<rule>>)*

private meta linearIndentSectionItemsVirtual ::= <<rule>> ((VIRTUAL_END_DECL | SEMICOLON VIRTUAL_END_DECL?) <<rule>>)*
private meta linearIndentSectionItemsSemicolon ::= <<rule>> (SEMICOLON <<rule>>)*
meta linearIndentSection ::= VIRTUAL_OPEN_SECTION <<linearIndentSectionItemsVirtual <<rule>> >> SEMICOLON? VIRTUAL_END_SECTION
                        | LEFT_BRACE <<linearIndentSectionItemsSemicolon <<rule>> >> SEMICOLON? RIGHT_BRACE
                        | <<rule>> {
    implements="proc.psi.ProcScopeElement"
    mixin="proc.psi.mixin.indentsection.ProcLinearIndentSectionMixin"
}

meta nestedIndentSectionItemsVirtual ::= <<rule>> ((VIRTUAL_END_DECL | SEMICOLON VIRTUAL_END_DECL?) <<nestedIndentSectionItemsVirtual <<rule>> >>)? {
    implements="proc.psi.ProcScopeElement"
    mixin="proc.psi.mixin.indentsection.ProcNestedIndentSectionItemsMixin"
}
meta nestedIndentSectionItemsSemicolon ::= <<rule>> (SEMICOLON <<nestedIndentSectionItemsSemicolon <<rule>> >>)? {
    implements="proc.psi.ProcScopeElement"
    mixin="proc.psi.mixin.indentsection.ProcNestedIndentSectionItemsMixin"
}
meta nestedIndentSection ::= VIRTUAL_OPEN_SECTION <<nestedIndentSectionItemsVirtual <<rule>> >> SEMICOLON? VIRTUAL_END_SECTION
                        | LEFT_BRACE <<nestedIndentSectionItemsSemicolon <<rule>> >> SEMICOLON? RIGHT_BRACE
                        | <<rule>>


/* Varids and Conids */
private extendedVarid ::= VARID | weakKeyword
private weakKeyword ::= AS | HIDING | INLINE | MUTABLE | PURE
varidUsage ::= extendedVarid {
    implements=["proc.psi.ProcCompositeElement"
                "proc.psi.ProcResolvableElement"]
    mixin="proc.psi.mixin.ProcVaridUsageMixin"
}
conidUsage ::= CONID {
    implements=["proc.psi.ProcCompositeElement"
                "proc.psi.ProcResolvableElement"
                "com.intellij.psi.PsiIdentifier"]
    mixin="proc.psi.mixin.ProcConidUsageMixin"
}

qualifier ::= conidUsage DOT
qLexOperator ::= qualifier? qualifier? lexOperator
qVarid ::= qualifier qualifier varidUsage | qualifier varidUsage | varidUsage
qConid ::= qualifier qualifier conidUsage | qualifier conidUsage | conidUsage

// For real usages of these pseudo-keywords (for highlighting)
meta strongKeyword ::= <<keyword>>
private strongAs ::= <<strongKeyword AS>>
private strongHiding ::= <<strongKeyword HIDING>>
private strongInline ::= <<strongKeyword INLINE>>
private strongMutable ::= <<strongKeyword MUTABLE>>
private strongPure ::= <<strongKeyword PURE>>
// for detecting usage 'package' instead of 'module' TODO
strongPackage ::= <<strongKeyword PACKAGE>>
strongModule ::= <<strongKeyword MODULE>>


/* Literals */
literal ::= boolLiteral
          | numericLiteral
          | CHAR
          | stringLiteral
          | REGEX
stringLiteral ::= STRING
numericLiteral ::= integralLiteral | floatLiteral
boolLiteral ::= TRUE | FALSE
integralLiteral ::= INTEGER
floatLiteral ::= FLOAT

/* Documentation */
lineDocumentation ::= LINE_DOC
blockDocumentation ::= BLOCK_DOC
documentation ::= lineDocumentation | blockDocumentation {
    implements="proc.psi.ProcDocumentationElement"
    mixin="proc.psi.mixin.ProcDocumentationMixin"
}

/* Proc Program */
program ::= ((documentation VIRTUAL_END_DECL)* PROTECTED_MODIFIER? (strongPackage | strongModule) packageName inlineRule? WHERE VIRTUAL_OPEN_SECTION)? body {
    pin=1
    implements="proc.psi.ProcPsiClass"
    mixin="proc.psi.mixin.ProcProgramMixin"
    stubClass="proc.stubs.ProcProgramStub"
}
packagePrefix ::= (packageToken DOT)*
packageName ::= packagePrefix conidUsage
private packageVarid ::= extendedVarid | DATA | IMPORT | NATIVE | PACKAGE | MODULE | TYPE
packageToken ::= (packageVarid | CONID) {
    implements="proc.psi.ProcCompositeElement"
    mixin="proc.psi.mixin.imports.ProcPackageTokenMixin"
}
inlineRule ::= strongInline extendedVarid* LEFT_PAREN <<commaSequence (qVarid | qLexOperator)>> RIGHT_PAREN


/* Recovers */
private declRecover ::= !(VIRTUAL_END_DECL)


/* Importing Packages */
importDecl ::= IMPORT importPackageName (strongAs? importDeclAlias)? PUBLIC_MODIFIER? importList? {
    pin=1
}
importList ::= strongHiding? LEFT_PAREN (<<commaSequence importSpec>>)? RIGHT_PAREN
importSpec ::= PUBLIC_MODIFIER? importItem importAlias?
importItem ::= qVaridUsageImport
             | conidUsageImport importMembers?
             | symbolOperatorImport
             | LEFT_PAREN symbolOperatorImport RIGHT_PAREN
             | BACK_QUOTE symbolOperatorImport BACK_QUOTE
             | conidUsageImport DOT (varidUsageImport | conidUsageImport | symbolOperatorImport)
importAlias ::= varidUsageImport | CONID | symbolOperatorImport
importMembers ::= LEFT_PAREN (<<commaSequence importMemberSpec>>)? RIGHT_PAREN
importMemberSpec ::= PUBLIC_MODIFIER? importMember importAlias?
importMember ::= varidUsageImport | symbolOperatorImport | conidUsageImport
/* Names and aliases for imports */
importDeclAlias ::= conidUsage {
    implements="proc.psi.ProcPsiClass"
    mixin="proc.psi.mixin.imports.ProcImportDeclAliasMixin"
}
conidUsageImport ::= CONID {
    implements=["proc.psi.ProcCompositeElement"
                "proc.psi.ProcResolvableElement"]
    mixin="proc.psi.mixin.imports.ProcConidUsageImportMixin"
}
varidUsageImport ::= extendedVarid {
    implements=["proc.psi.ProcCompositeElement"
                "proc.psi.ProcResolvableElement"]
    mixin="proc.psi.mixin.imports.ProcVaridUsageImportMixin"
}
qVaridUsageImport ::= (conidUsageImport DOT)? (conidUsageImport DOT)? varidUsageImport
symbolOperatorImport ::= symbolOperatorQuoted {
    implements=["proc.psi.ProcCompositeElement"
                "proc.psi.ProcResolvableElement"]
    mixin="proc.psi.mixin.imports.ProcSymbolOperatorImportMixin"
}

importPackageName ::= packagePrefix importPackageClassName
importPackageClassName ::= CONID {
    implements=["proc.psi.ProcCompositeElement"
                "com.intellij.psi.PsiIdentifier"]
    mixin="proc.psi.mixin.imports.ProcImportPackageClassNameMixin"
}


/* Main part of program */
body ::= (documentation | topDecl) (VIRTUAL_END_DECL (documentation | topDecl))* {
    implements="proc.psi.ProcScopeElement"
    mixin="proc.psi.mixin.ProcBodyMixin"
}


/* Top-level declarations */
topDecl ::= !<<eof>> (
              fixity
            | importDecl
            | typeDecl
            | dataDecl
            | newtypeDecl
            | nativeDataDecl
            | classDecl
            | instanceDecl
            | deriveDecl
            | nativeModule
            | decl) SEMICOLON? {
    pin=1
    recoverWhile=declRecover
}


/* Access Modifiers */
accessModifier ::= PUBLIC_MODIFIER | PROTECTED_MODIFIER | PRIVATE_MODIFIER {
    implements="proc.psi.ProcCompositeElement"
    mixin="proc.psi.mixin.ProcAccessModifierMixin"
    stubClass="proc.stubs.ProcAccessModifierStub"
}

/* Where Sections */
whereSection ::= WHERE <<linearIndentSection (documentation | decl)>> {
    pin=1
}


/* Functions */
decl ::= annotation | binding | nativeFunction {
    implements="proc.psi.ProcSubprogramsHolder"
}


/* Bindings */
binding ::= accessModifier? lhs rhs documentation? {
    implements=["proc.psi.ProcPsiMethod"
                "proc.psi.ProcParametersHolder"
                "proc.psi.ProcWeakScopeElement"]
    mixin="proc.psi.mixin.ProcBindingMixin"
    stubClass="proc.stubs.ProcMethodStub"
}
lhs ::= functionLhs | pattern
functionLhs ::= functionLexOperatorLhs
              | (functionName | LEFT_PAREN symbolOperatorQuoted RIGHT_PAREN) patternTerms?
private functionLexOperatorLhs ::= patternTerms lexOperator patternTerms
                                 | LEFT_PAREN patternTerms lexOperator patternTerms RIGHT_PAREN
rhs ::= (rhsExpression | guardedExpressions) whereSection? {
    pin=1
}
private rhsExpression ::= EQUAL expr {
    pin=1
}
functionName ::= extendedVarid {
    implements=["proc.psi.ProcCompositeElement"
                "com.intellij.psi.PsiIdentifier"]
    mixin="proc.psi.mixin.ProcFunctionNameMixin"
}


/*  Binding Annotations */
annotation ::= accessModifier? annotationItem (COMMA annotationItem)* DOUBLE_COLON sigma documentation? {
    pin=4
    implements="proc.psi.ProcTypeParametersHolder"
    mixin="proc.psi.mixin.ProcAnnotationMixin"
}
annotationItem ::= annotationName | LEFT_PAREN symbolOperatorQuoted RIGHT_PAREN | unaryOperator {
    implements="proc.psi.ProcPsiMethod"
    mixin="proc.psi.mixin.ProcAnnotationItemMixin"
    stubClass="proc.stubs.ProcMethodStub"
}
annotationName ::= extendedVarid {
    implements=["proc.psi.ProcCompositeElement"
                "com.intellij.psi.PsiIdentifier"]
    mixin="proc.psi.mixin.ProcAnnotationNameMixin"
}


/* Native Bindings */
nativeFunction ::= accessModifier? strongPure? NATIVE nativeAnnotationItem javaItem? nativeTypeApplications? DOUBLE_COLON sigma throwsSequence? (VERTICAL_BAR sigma throwsSequence?)* documentation? {
    pin=4
    implements="proc.psi.ProcPsiMethod"
    mixin="proc.psi.mixin.ProcNativeFunctionMixin"
    stubClass="proc.stubs.ProcMethodStub"
}
nativeTypeApplications ::= LEFT_BRACE (<<commaSequence typeApplications>>)? RIGHT_BRACE
javaItem ::= nativeName | unaryOperator | symbolOperatorQuoted
throwsSequence ::= THROWS <<commaSequence typeApplications>>
nativeAnnotationItem ::= nativeFunctionName | LEFT_PAREN (symbolOperatorQuoted | unaryOperator) RIGHT_PAREN | (symbolOperatorQuoted | unaryOperator)
nativeFunctionName ::= extendedVarid {
    implements=["proc.psi.ProcCompositeElement"
                "com.intellij.psi.PsiIdentifier"]
    mixin="proc.psi.mixin.ProcNativeFunctionNameMixin"
}


/* Fixity */
fixity ::= infixRule precedence (qLexOperator | extendedVarid)+ {
    pin=1
}
precedence ::= INTEGER
infixRule ::= INFIX | INFIXL | INFIXR


/* Type Declarations */
typeDecl ::= accessModifier? TYPE conidUsage typedVarid* EQUAL sigma {
    pin=2
    implements=["proc.psi.ProcPsiClass"
                "proc.psi.ProcTypeParametersHolder"]
    mixin="proc.psi.mixin.ProcTypeDeclMixin"
    stubClass="proc.stubs.ProcClassStub"
}


/* Class Declarations */
// TODO take class name out of constraints. After that fix it in mixin!
classDecl ::= accessModifier? (CLASS | INTERFACE) constraints ( DOUBLE_RIGHT_ARROW conidUsage typedVarid)?  whereSection? {
    pin=2
    implements=["proc.psi.ProcPsiClass"
                "proc.psi.ProcTypeParametersHolder"]
    mixin="proc.psi.mixin.ProcClassDeclMixin"
    stubClass="proc.stubs.ProcClassStub"
}


/* Instance Declarations */
instanceDecl ::= accessModifier? INSTANCE (constraints DOUBLE_RIGHT_ARROW)? qConid typeApplications whereSection? {
    pin=2
    implements=["proc.psi.ProcPsiClass"
                "proc.psi.ProcTypeParametersHolder"]
    mixin="proc.psi.mixin.ProcInstanceDeclMixin"
    stubClass="proc.stubs.ProcClassStub"
}


/* Derived Instances */
deriveDecl ::= accessModifier? DERIVE conidUsage (constraints DOUBLE_RIGHT_ARROW)? typeApplications {
    pin=2
    implements="proc.psi.ProcTypeParametersHolder"
    mixin="proc.psi.mixin.ProcDeriveDeclMixin"
}


/* Data Declarations */
dataDecl ::= accessModifier? ABSTRACT? DATA conidUsage typedVarid* EQUAL constructs whereSection? deriveDecl? documentation? {
    pin=7
    implements=["proc.psi.ProcPsiClass"
                "proc.psi.ProcTypeParametersHolder"]
    mixin="proc.psi.mixin.ProcDataDeclMixin"
    stubClass="proc.stubs.ProcClassStub"
}
constructs ::= construct (VERTICAL_BAR construct)*
construct ::= documentation? accessModifier? (EXLAMATION_MARK? conidUsage) (
          LEFT_BRACE constructorFields RIGHT_BRACE | simpleType*) documentation? {
    implements="proc.psi.ProcPsiMethod"
    mixin="proc.psi.mixin.ProcConstructMixin"
    stubClass="proc.stubs.ProcMethodStub"
}
private constructorFields ::= constructorField ((COMMA | documentation) constructorField)* (COMMA | documentation)?
private constructorField ::= documentation* labels DOUBLE_COLON sigma
labels ::= <<commaSequence label>>
label ::= EXLAMATION_MARK? labelName {
    implements="proc.psi.ProcPsiMethod"
    mixin="proc.psi.mixin.ProcLabelMixin"
    stubClass="proc.stubs.ProcMethodStub"
}
labelName ::= extendedVarid {
    implements=["proc.psi.ProcCompositeElement"
                "com.intellij.psi.PsiIdentifier"]
    mixin="proc.psi.mixin.ProcLabelNameMixin"
}

/* Newtype Declarations */
newtypeDecl ::= accessModifier? ABSTRACT? NEWTYPE conidUsage typedVarid* EQUAL construct whereSection? {
    pin=3
    implements=["proc.psi.ProcPsiClass"
                "proc.psi.ProcTypeParametersHolder"]
    mixin="proc.psi.mixin.ProcNewtypeDeclMixin"
    stubClass="proc.stubs.ProcClassStub"
}


/* Native Data Declarations */
nativeDataDecl ::= accessModifier? DATA conidUsage typedVarid* EQUAL (strongMutable|strongPure)? NATIVE nativeName nativeTypeApplications? whereSection? deriveDecl? {
    pin=7
    implements=["proc.psi.ProcPsiClass"
                "proc.psi.ProcTypeParametersHolder"]
    mixin="proc.psi.mixin.ProcNativeDataDeclMixin"
    stubClass="proc.stubs.ProcClassStub"
}
nativeName ::= ((extendedVarid | CONID) DOT)* (extendedVarid | CONID | stringLiteral) {
    implements="proc.psi.ProcCompositeElement"
    mixin="proc.psi.mixin.ProcNativeNameMixin"
}

/* Native module */
nativeModule ::= accessModifier? NATIVE MODULE (TYPE typeApplications)? (CLASS <<commaSequence constraint>>)? WHERE LEFT_BRACE javaCode RIGHT_BRACE {
    pin=3
}
external javaCode ::= javaCodeParseExternal


/* Expression */
expr ::= binaryExpression (DOUBLE_COLON (FORALL | rho))?
binaryExpression ::= DASH? topExpression (qLexOperator topExpression)*
topExpression ::= condition
                | letInExpression
                | caseExpression
                | lambda
                | ((EXLAMATION_MARK | QUESTION_MARK)* primary)+

/* Lambda Expressions */
lambda ::= BACK_SLASH pattern (lambda | RIGHT_ARROW expr) {
    implements="proc.psi.ProcParametersHolder"
}

/* Do Expressions */
doExpression ::= DO <<nestedIndentSection (doDecl | qConid LEFT_BRACE fieldsOrVaridInit RIGHT_BRACE)>>
doDecl ::= letExpression | pattern (LEFT_ARROW | EQUAL) expr | expr {
    implements=["proc.psi.ProcSubprogramsHolder"
                "proc.psi.ProcScopeElement"]
    mixin="proc.psi.mixin.indentsection.ProcDoDeclMixin"
}

/* Case Expressions */
caseExpression ::= CASE expr OF <<linearIndentSection caseDecl>> {
    pin=1
}
caseDecl ::= pattern ((RIGHT_ARROW | EQUAL) expr | guardedExpressions) whereSection? {
    pin=2
    implements=["proc.psi.ProcParametersHolder"
                "proc.psi.ProcWeakScopeElement"]
    mixin="proc.psi.mixin.indentsection.ProcCaseDeclMixin"
}

/* If Condition Expressions */
condition ::= IF expr (VIRTUAL_END_DECL | SEMICOLON)? THEN expr (VIRTUAL_END_DECL | SEMICOLON)? ELSE expr {
    pin=1
}

/* Let Expressions */
letExpression ::= LET <<linearIndentSection decl>> {
    pin=1
}
letInExpression ::= letExpression IN expr {
    pin=1
    implements="proc.psi.ProcScopeElement"
    mixin="proc.psi.mixin.indentsection.ProcLetInExpressionMixin"
}

/* Guarded Expressions */
guardedExpressions ::= guardedExpression+
guardedExpression ::= VERTICAL_BAR guardDecls (RIGHT_ARROW | EQUAL) expr {
    pin=1
}
guardDecls ::= <<commaSequence guardDecl>> COMMA?
guardDecl ::= expr (LEFT_ARROW expr)?


/* Primary Expression */
primary ::= (term | doExpression) (DOT (
                extendedVarid
              | qLexOperator
              | EXLAMATION_MARK
              | QUESTION_MARK
              | LEFT_BRACE fieldsOrVaridInit RIGHT_BRACE
              | LEFT_BRACKET expr RIGHT_BRACKET))*
fieldsOrVaridInit ::= extendedVarid (
                                     QUESTION_MARK
                                   | COMMA <<commaSequence getField>>
                                   | (LEFT_ARROW | EQUAL) expr? (COMMA <<commaSequence getField>>)?)? COMMA?
getField ::= extendedVarid ((LEFT_ARROW | EQUAL) expr)?

/* Terms */
term ::= qVarid
       | qConid LEFT_BRACE initFields? RIGHT_BRACE
       | qConid
       | literal
       | LEFT_PAREN qLexOperator RIGHT_PAREN
       | LEFT_PAREN unaryOperator RIGHT_PAREN
       | LEFT_PAREN expr RIGHT_PAREN
       | list
       | slice
       | unit
       | tuple
       | UNDERSCORE
initFields ::= <<commaSequence initField>>
initField ::= extendedVarid (EQUAL expr)?
slice ::= LEFT_PAREN (binaryExpression qLexOperator | qLexOperator expr) RIGHT_PAREN
unit ::= LEFT_PAREN RIGHT_PAREN
tuple ::= tupleConstructor | nTuple | strictNTuple
tupleConstructor ::= LEFT_PAREN COMMA* RIGHT_PAREN
nTuple ::= LEFT_PAREN expr COMMA <<commaSequence expr>> COMMA? RIGHT_PAREN
strictNTuple ::= LEFT_PAREN expr SEMICOLON <<semicolonSequence expr>> SEMICOLON? RIGHT_PAREN

/* Lists */
list ::= emptyList
       | LEFT_BRACKET <<commaSequence expr>> COMMA? RIGHT_BRACKET
       | LEFT_BRACKET expr (COMMA expr)? DOUBLE_DOT expr? RIGHT_BRACKET
       | LEFT_BRACKET expr VERTICAL_BAR <<commaSequence doDecl>> COMMA? RIGHT_BRACKET
emptyList ::= LEFT_BRACKET RIGHT_BRACKET

/* Patterns */
pattern ::= atPattern (DOUBLE_COLON sigma)* {
    pin=1
}
atPattern ::= parameterPattern AT atPattern
            | matcherPattern (COLON matcherPattern)*
matcherPattern ::= parameterPattern TILDA REGEX | patternTerms
patternTerms ::= patternTerm+
patternTerm ::= (EXLAMATION_MARK | QUESTION_MARK)?
                  ( qConid LEFT_BRACE patternFields? RIGHT_BRACE
                  | LEFT_PAREN <<commaSequence pattern>> RIGHT_PAREN
                  | qConid
                  | parameterPattern
                  | literal
                  | unit
                  | tuple
                  | emptyList
                  | LEFT_BRACKET pattern (COMMA pattern)* RIGHT_BRACKET
                  | LEFT_PAREN parameterPattern SUPER_OR_SUBSCRIPT RIGHT_PAREN)
parameterPattern ::= parameter | UNDERSCORE
patternFields ::= <<commaSequence patternField>>
patternField ::= parameter (EQUAL pattern)?
parameter ::= extendedVarid {
    mixin="proc.psi.mixin.ProcParamMixin"
    implements="proc.psi.ProcNamedElement"
}


/* Types */
sigma ::= (FORALL typedVarid+ (DOT | symbolOperatorQuoted))? (constraints DOUBLE_RIGHT_ARROW)? rho
rho ::= LEFT_PAREN sigma RIGHT_PAREN RIGHT_ARROW rho
      | typeApplication RIGHT_ARROW rho
      | typeApplication
constraints ::= constraint | LEFT_PAREN <<commaSequence constraint>> COMMA? RIGHT_PAREN
constraint ::= qConid typeApplication+
typeApplications ::= typeApplication (RIGHT_ARROW typeApplication)*
typeApplication ::= simpleType+

simpleType ::= typedVarid
             | typedConid
             | LEFT_PAREN typeApplications RIGHT_PAREN
             | LEFT_PAREN typeApplications COMMA typeApplications (COMMA typeApplications)* RIGHT_PAREN
             | LEFT_BRACKET typeApplications RIGHT_BRACKET
             | LEFT_PAREN typeApplications VERTICAL_BAR typeApplications (VERTICAL_BAR typeApplications)* RIGHT_PAREN
typedVarid ::= typeParameter | LEFT_PAREN typeParameter DOUBLE_COLON kind RIGHT_PAREN {
    implements="proc.psi.ProcNamedElement"
    mixin="proc.psi.mixin.ProcTypedVaridMixin"
}
typedConid ::= qConid
             | emptyList
             | unit
             | tupleConstructor
             | RIGHT_ARROW
typeParameter ::= extendedVarid | LEFT_PAREN (extendedVarid LEQ typeApplication | GEQ extendedVarid) RIGHT_PAREN {
    implements="proc.psi.ProcCompositeElement"
    mixin="proc.psi.mixin.ProcTypeParameterMixin"
}
kind ::= simpleKind (RIGHT_ARROW kind)?
simpleKind ::= STAR | LEFT_PAREN kind RIGHT_PAREN


/* Operators */
private reservedAloneOperators ::= DASH | STAR | COLON | SUPER_OR_SUBSCRIPT
                                  | AT | TILDA | EXLAMATION_MARK | QUESTION_MARK // TODO AT is not an operator
symbolOperator ::= SYMOP_NO_RESERVED | reservedAloneOperators {
    implements=["proc.psi.ProcCompositeElement"
                "proc.psi.ProcResolvableElement"
                "com.intellij.psi.PsiIdentifier"]
    mixin="proc.psi.mixin.ProcSymbolOperatorMixin"
}
symbolOperatorQuoted ::= symbolOperator | BACK_QUOTE symbolOperator BACK_QUOTE
private wordOperatorQuoted ::= BACK_QUOTE wordOperator BACK_QUOTE
wordOperator ::= extendedVarid | CONID {
    implements=["proc.psi.ProcCompositeElement"
                "proc.psi.ProcResolvableElement"
                "com.intellij.psi.PsiIdentifier"]
    mixin="proc.psi.mixin.ProcWordOperatorMixin"
}
lexOperator ::= wordOperatorQuoted | symbolOperatorQuoted
unaryOperator ::= EXLAMATION_MARK | QUESTION_MARK


//noinspection BnfUnusedRule
unusedInBnf ::= NEW_LINE | LINE_COMMENT | BLOCK_COMMENT


/*
// Any other characters to extend language.
         OtherLetter ::=
          OtherDigit ::=

// Base language characters.
         LatinLetter ::= "A" | "B" ... "Z" | "a" | "b" | ... | "z"
        DecimalDigit ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

// Proc letters and digits.
              Letter = LatinLetter | OtherLetter | OtherDigit
               Digit = DecimalDigit | LatinLetter.

// Language strings.
           Character = Letter | Digit.
                Char = "'" { Char } "'".
              String = "\"" { Char } "\"".
              Number = { Digit }.

// Proc syntax.
          Identifier = Letter { Letter | Digit }.
           Statement = { Assignment } |
                       { IfStatement } |
                       { CaseStatement } |
                       { WhileStatement } |
                       { DoWhileStatement } |
                       { ForStatement } |
                       { Call }.

                Type = Number { "[" Number "]" } | Identifier.
                Cast = "(" Type ")".
      AccessModifier = "private" | "protected" | "public".

         Declaration = [ AccessModifier ] [ "static" | "const" ] Type Identifier [ "=" Expression ]

 ConstantDeclaration = [ AccessModifier ] "const" Type Identifier "=" ConstantExpression.
 VariableDeclaration = (* Здесь надо подумать о области видимости переменных в функции *)

         Declaration = { ConstantDeclaration }
                       { FieldDeclaration }
                       { FunctionDeclaration }
                       { ClassDeclaration }

// Many programming languages make a distinction between statements and definitions/declarations but not this.
               Scope = { Statement }

// Goal of process is a top scope.
                Goal = Scope
                Proc = Goal
*/
