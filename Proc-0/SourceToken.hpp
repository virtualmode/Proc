#pragma once

#ifndef SOURCE_TOKEN_H
#define SOURCE_TOKEN_H

#include "Temp/Dependency.h"

#include "Char.hpp"
#include "CharToken.hpp"
#include "SymbolType.hpp"

/*
	4. Первичная обработка исходного кода для компилятора или интерпретатора начинается с лексического анализа. Есть
	несколько способов реализации: обычная реализация, интерпретатор БНФ или регулярных выражений, компилятор
	анализаторов типа Lex. Для базовых языков подойдёт первый вариант, как самый простой и производительный.
	Если рассмотреть вообще любые данные, то при их первичной обработке происходит лексический анализ по сути, но место
	лексем могут занимать специфические конструкции: состояния, символы, цвета, заголовки, звуковые сэмплы и прочее.
	Чтение этих конструкций из потоков, запись и другие операции можно представить как часть одного и того же процесса.
	Такие классы задач можно выделить суффиксами в соответствии от их назначения, например Reader, Writer или Seeker.
*/

// Лексический анализатор исходного кода. Машина состояний. Конечный автомат.
// В других источниках можно встретить варианты: lexical analyzer, lexer, tokenizer, scanner, token reader.
// TODO Анализатор работает с Юникод текстом и наверное максимум может быть совместим с подобными кодировками,
// TODO но есть ли смысл так делать, непонятно. Типа это UnicodeLexer и должен работать только с Юникодом.
// TODO Если потребуется работать с другими источниками исходников, то для них должен быть написан свой анализатор.
class SourceToken {

private:

	CharToken *_charToken;

public:

	// Тип символа.
	SymbolType Type;

	// Нужно реализовать потоки состояний и возможность использования на них объединений union или cast.
	char Value[128]; // Предполагается, что это и будет единственный поток состояний, хранящий значение лексемы.
	// Язык не должен ограничивать размер чисел из-за архитектуры процессора.
	int Symbol; // [Obsolete] Текущий код символа Юникода.
	long Number; // [Obsolete] Значение целого числа.
	double Real; // [Obsolete] Значение числа с плавающей точкой.

	// Основной конструктор.
	SourceToken(CharToken *charToken) {
		// TODO Это не токен в чистом виде, скорее надо переименовать в машину состояний.
		// TODO И передавать композицию интерфейсов CharToken и CharReader например.
		// TODO Но может быть если класс будет работать как дизассемблер, то и CharWriter.
		_charToken = charToken;
	}

	~SourceToken() {
	}

	// Чтение очередной лексемы. Простейший шаг, определяющий следующий автомат.
	// Результат чтения не имеет значения, т.к. синтаксический анализатор сам решает,
	// является ли для него состояние машины приемлемым для следующего шага.
	virtual void ReadToken() {
		_charToken->ReadChar(); // Перевод машины в следующее состояние.

		// Если нет возможности прочесть очередное состояние из потока.
		if (_charToken->EndOfText) {
			Type = SymbolType::EndOfStream;
			return;
		}
		
		// Переход к следующему состоянию.
		if (_charToken->Value == (int)Char::Space)
		{

		}

		/*switch (unicode) {
			case 0:
				break;

			default:
				if (_unicodeToken->IsDigit()) {
					//Number();
				} else if (ch >= 'A' && ch <= 'Z' || ch >= 'a' && ch <= 'z') {
					//Ident();
				} else if (ch == '~') {
					//chRead();
					//sym = NOT;
				} else {
					//chRead();
					//sym = _NULL;
				}
				break;
		}

		// Отладочная информация.
		if (unicode < 256)
			printf_s("%c", unicode);
		else
			printf_s("[%u]", unicode);*/
	}
};

#endif // SOURCE_TOKEN_H
