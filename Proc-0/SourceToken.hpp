#pragma once

#ifndef SOURCE_TOKEN_H
#define SOURCE_TOKEN_H

#include "Temp/Dependency.h"

#include "UnicodeReader.hpp"
#include "UnicodeWriter.hpp"

/*
	4. Первичная обработка исходного кода для компилятора или интерпретатора начинается с лексического анализа. Есть
	несколько способов реализации: обычная реализация, интерпретатор БНФ или регулярных выражений, компилятор
	анализаторов типа Lex. Для базовых языков подойдёт первый вариант, как самый простой и производительный.
	Если рассмотреть вообще любые данные, то при их первичной обработке происходит лексический анализ по сути, но место
	лексем могут занимать специфические конструкции: состояния, символы, цвета, заголовки, звуковые сэмплы и прочее.
	Чтение этих конструкций из потоков, запись и другие операции можно представить как часть одного и того же процесса.
	Такие классы задач можно выделить суффиксами в соответствии от их назначения, например Reader, Writer или Seeker.
*/

// Лексический анализатор исходного кода. Машина состояний. Конечный автомат.
// В других источниках можно встретить варианты: lexical analyzer, lexer, tokenizer, scanner, token reader.
class SourceToken {

private:

	// Текущий код символа Юникода.
	//int _symbol;

public:

	// Можно реализовать Union.
	// Не хочется использовать в данном случае наследование.
	int Value;
	int FloatValue;
	char id[16];

	// Основной конструктор.
	SourceToken() {
	}

	~SourceToken() {
	}

	// Чтение очередной лексемы.
	// Основная машина состояний лексического анализатора, выполняющая простейший шаг и определяющая следующий автомат.
	// @return Успешность прочтённой лексемы.
	virtual bool ReadToken(UnicodeReader *reader) {
		int symbol = reader->ReadChar();
		if (symbol >= 0) {
			if (symbol < 256)
				printf_s("%c", symbol);
			else
				printf_s("[%u]", symbol);

			return 1;
		}
		
		return 0;
	}
};

#endif // SOURCE_TOKEN_H
