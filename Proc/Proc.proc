/*
	Proc(ess(or))
*/

use var = [] // Псевдоним для типа ленты неизвестной длины.
use bit = 2

// Булев тип данных.
public final class Boolean
	private bit _value

use bool = Boolean // TODO Это уже класс! Может зеленый цвет для bool использовать?

// Целочисленный тип.
public class Integer

	private var _value

	public Integer()

	// Перегрузка оператора присваивания.
	// @value Присваиваемое значение.
	public void operator =(var value)
		//if (value.Base == 16) // Через стек прокидывать надо.

public class String
	// TODO Для AccessModifier можно в принципе использовать оба варианта, как C++ и C#.
	private var _value
	public String()
	public void operator =(var value)



if (GetBoolFunc()) // Здесь просто возвращён bool.
if (intA > intB) // Как превратить непонятно что в bool? Переопределить оператор у int и вернуть bool.
if (bool) // Как оператор if без булева оператора должен работать с типом bool, который еще не реализован?
// Фактически вот такое представление кода. Что это значит? Оператор должен быть и если он опущен, то всё равно какой-то подразумевается.
// Какой? "> 0" ? "== 1" ?
if (intA > intB, true)
	A
else
	B

use if (<value>) <caseA> else <caseB>
	switch (value)
		case true
			caseA
		default
			caseB

/*
	Использование оператора use (using, import, #include).
	1. Подключение пространства имён.
	2. Подключение отдельного типа данных (как в Java) или пространства через *.
	3. Определение псевдонима для типа данных (дополнительно можно реализовать модификаторы типа global или static как в C#).
	4. Определение области видимости для переменной (как в C# для IDisposable)?
	5. Определение псевдонима для данных?
*/

// Эта штука больше для типов подходит.
use false = 0
use true = 1

// Вариант реализации булевых констант.
const bool false = bool.BooleanFalse()
const bool true = bool.BooleanTrue()

use bool = Boolean // Алиасы можно отображать как встроенные типы в других языках.
use int = Integer // В данном случае это не совсем классический int.
use string = String

void Write(string text)
	//#proc masm
	//mov ax, dx
	//#proc

// TODO При выполнении листинга предполагается неявно использовать что-то типа varargs для передачи параметров в top scope листинга.
// TODO Верхний процессор может выполнить листинг с переменным количеством аргументов, как это делается в обычной оболочке.
// TODO Например вызов функции 'proc("src.proc", arg1, arg2, arg3)' или более привычной формы 'proc src.proc arg1 arg1 arg3'.
public void Proc(string fileName, ...)
	//WriteLine("Proc started with: $_args.joinToString()")

// Когда код уже загружен в память, пространство имён уже содержит часть функций для выполнения.
// Возможно импортировать листинг и, если требуется, вызвать собственную точку входа с определёнными параметрами.
public void ProcCompile(string fileName)
	// Лексический анализ файла.
	//_source = FileStream(_args[1]) // Базовый поток состояний, используемый процессором и дочерними анализаторами.
	//_destination = new Interop.FileStream($"{Path.GetFileNameWithoutExtension(_args[1])}.exe", FileMode.Create, FileAccess.Write)
	//_charReader = new Utf8((Reader)_source) // Символьный поток определённой кодировки.
	// В Roslyn следующие строки создаются в SyntaxTree Oo.
	//_lexer = new ProcSymbol(_charReader) // Лексический анализатор исходного кода.
	//_syntaxReader = new ProcSyntax(_lexer) // Синтаксический анализатор.
	// TODO Генерацию можно выполнить несколькими путями:
	// TODO Получить готовое синтаксическое дерево и сгенерировать код.
	// TODO Или получить на вход синтаксический анализатор и в процессе генерации дерева, сформировать код.
	//_generator = new Generator(_destination, _syntaxReader)
	//_generator.CompileAndEmit()

// Обёртка для выполнения кода.
public void ProcRun(string fileName, string entryPoint)
	//use fileName
	//entryPoint()

// Эта функция должна выполняться операционной системой первой.
public void Proc()

	Write("Proc is started and you are at top of this process.\n")
	Write("Please write code!\n\n")


// TODO Не совсем понятно как и когда будет выполняться top scope.
// TODO Скорее, какой листинг будет первым выполнен, тот код и будет иметь фактический приоритет.
Proc() // Точка входа.

return // Необязательный оператор, если возвращаемая лента из top scope нулевой длины.
