/*
	1. Указываем количество информации для типа (разрядность и основание).
	2. Указываем всегда минимальное основание 2 и количество разрядов (по сути биты, байты, как обычно).
	3. Не указываем количество информации для переменной (не знаю пока как в таком случае выделять её в памяти машины).

	Плотно упакованный протокол будет иметь особенности на разных архитектурах. Если он был создан в двоичном представлении,
	то возможно его представить в этом виде из любого основания. И операции над ним будут иметь смысл именно в двоичном
	представлении. Все другие основания дают возможность только хранить и передавать данные (это кстати неточно).
*/

/*
	INSPIRATION
	IS THE
	CULMINATION
	OF FOCUS
	AND DESIRE
	TO FIND THE
	BEST INSIDE
	YOURSELF
	AND BRING IT
	FORWARD
*/

 1 = 0
 2 = 1
 3 = 2
 4 = 3
 5 = 4
 6 = 5
 7 = 6
 8 = 7
 9 = 8
10 = 9
11 = A
12 = B
13 = C
14 = D
15 = E
16 = F
17 = G
18 = H
19 = I
20 = J
21 = K
22 = L
23 = M
24 = N
25 = O
26 = P
27 = Q
28 = R
29 = S
30 = T
31 = U
32 = V
33 = W
34 = X
35 = Y
36 = Z

// Идея: из типа данных убрать размер данных. Т.е. можно создавать переменную из 100 состояний и кастом указать, что это целое число:
// [100] Value; Value = (integer)24; [256] floatNumber = (real)Value;
// Т.е. размерность указывает объем переменной, а тип - способ хранения информации.
// Отличие от C++ будет видимо лишь в том, что нельзя явно будет написать, например float variable;

#define unit[256] char
enum[256] ?

#define [256] char
[256] symbol;
char symbol;
[256*256] word;
char word[256]; ?
char[256] word; ?
char char word;
[256][256] word; // Но

[3][17][6][4][8] lip; ? упакованный тип

[3][5] example;

-------------------

[256] char
[65536] word

-------------------

0xFF myhex = 128;
#define byte 0xFF
byte myhex2 = 0x96;

bit myvar;
256 chars;
256 chars[10]; // 10 символов.
256[2] shorts[10]; // 10 short'ов.
256^2 shorts[10]; // 10 short'ов.
unknown dest, src;

dest = (2^8^10)src;
dest = (5)src[2];

stream.Read(dest, 2^8);

2[8] test = 0x00101101
3[8] tern = 0x01221012 = max 6561
256 test2 = 0x10010010
256 test = 0fffff
3[6] test = 0
0xASFG
0a0010
59:40:45
ff:da:aa:fa:a1

2 4 8 16 32 - 64
3 9 27 - 81
4 16 - 64
5 25 - 125
6 36 - 216
7  - 49
8  - 64
9  - 81
10 - 100
11 - 121
