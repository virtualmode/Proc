/*
	1. Указываем количество информации для типа (разрядность и основание).
	2. Указываем всегда минимальное основание 2 и количество разрядов (по сути биты, байты, как обычно).
	3. Не указываем количество информации для переменной (не знаю пока как в таком случае выделять её в памяти машины).

	Плотно упакованный протокол будет иметь особенности на разных архитектурах. Если он был создан в двоичном представлении,
	то возможно его представить в этом виде из любого основания. И операции над ним будут иметь смысл именно в двоичном
	представлении. Все другие основания дают возможность только хранить и передавать данные (это кстати неточно).
*/

#define unit[256] char
enum[256] ?

#define [256] char
[256] symbol;
char symbol;
[256*256] word;
char word[256]; ?
char[256] word; ?
char char word;
[256][256] word; // Но

[3][17][6][4][8] lip; ? упакованный тип

[3][5] example;

-------------------

[256] char
[65536] word

-------------------

0xFF myhex = 128;
#define byte 0xFF
byte myhex2 = 0x96;

bit myvar;
256 chars;
256 chars[10]; // 10 символов.
256[2] shorts[10]; // 10 short'ов.
256^2 shorts[10]; // 10 short'ов.
unknown dest, src;

dest = (2^8^10)src;
dest = (5)src[2];

stream.Read(dest, 2^8);
